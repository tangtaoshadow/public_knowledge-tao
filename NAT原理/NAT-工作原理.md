# NAT穿透

## NAT对待UDP的实现方式



![image.png](https://cdn.nlark.com/yuque/0/2020/png/389953/1598862683071-4bcb180a-9860-4aaf-a564-ff2f71c2cc5d.png#align=left&display=inline&height=231&margin=%5Bobject%20Object%5D&name=image.png&originHeight=307&originWidth=622&size=20858&status=done&style=none&width=468)



### 完全锥型 『Full Cone NAT』


> IP+端口不限制



内部ip在NAT表中有申明过，则外部任意IP，端口均可以透过指定的IP、端口访问,一个映射进行复用


### IP限制型『Restricted Cone NAT』


> 外部的IP



### 端口限制型『Port Restricted Cone NAT』


> 外部IP+外部的端口



### 对称型『Symmetric NAT』


> 一个IP+端口 分配一个



相当于更严格的端口限制型


## NAT穿透


> 是在客户端都不知道对方的情况下,才需要建立的,知道了对方的IP,就不需要穿透了,直接连接



## 探测的方式


### 应用层网关


> 应用层网关(ALG)是解决NAT对应用层协议无感知的一个最常用方法，已经被NAT设备厂商广泛采用，成为NAT设备的一个必需功能。



因为NAT不感知应用协议，所以有必要额外为每个应用协议定制协议分析功能，这样NAT网关就能理解并支持特定的协议。


ALG与NAT形成互动关系，在一个NAT网关检测到新的连接请求时，需要判断是否为已知的应用类型，这通常是基于连接的传输层端口信息来识别的。在识别为已知应用时，再调用相应功能对报文的深层内容进行检查，当发现任何形式表达的IP地址和端口时，将会把这些信息同步转换，并且为这个新连接创建一个附加的转换表项。这样，当报文到达公网侧的目的主机时，应用层协议中携带的信息就是NAT网关提供的地址和端口。一旦公网侧主机开始发送数据或建立连接到此端口，NAT网关就可以根据关联表信息进行转换，再把数据转发到私网侧的主机。


#### 注意


很多应用层协议实现不限于一个初始连接(通常为信令或控制通道)加一个数据连接，可能是一个初始连接对应很多后续的新连接。比较特别的协议，在一次协商中会产生一组相关连接，比如RTP/RTCP协议规定，一个RTP通道建立后占用连续的两个端口，一个服务于数据，另一个服务于控制消息。此时，就需要ALG分配连续的端口为应用服务。ALG能成功解决大部分协议的NAT穿越需求，但是这个方法也有很大的限制。因为应用协议的数量非常多而且在不断发展变化之中，添加到设备中的ALG功能都是为特定协议的特定规范版本而开发的，协议的创新和演进要求NAT设备制造商必须跟踪这些协议的最近标准，同时兼容旧标准。尽管有如Linux这种开放平台允许动态加载新的ALG特性，但是管理成本仍然很高，网络维护人员也不能随时了解用户都需要什么应用。因此为每个应用协议开发ALG代码并跟踪新标准是不可行的，ALG只能解决用户最常用的需求。此外，出于安全性需要，有些应用类型报文从源端发出就已经加密，这种报文在网络中间无法进行分析，所以ALG无能为力。


### 探针技术STUN和TURN


所谓探针技术，是通过在所有参与通信的实体上安装探测插件，以检测网络中是否存在NAT网关，并对不同NAT模型实施不同穿越方法的一种技术。**STUN服务器被部署在公网上**『中继服务器/协调者』，用于接收来自通信实体的探测请求，服务器会记录收到请求的报文地址和端口，并填写到回送的响应报文中。客户端根据接收到的响应消息中记录的地址和端口与本地选择的地址和端口进行比较，就能识别出是否存在NAT网关。如果存在NAT网关，客户端会使用之前的地址和端口向服务器的另外一个IP发起请求，重复前面的探测。然后再比较两次响应返回的结果判断出NAT工作的模式。由前述的一对多转换模型得知，除对称型NAT以外的模型，NAT网关对内部主机地址端口的映射都是相对固定的，所以比较容易实现NAT穿越。而对称型NAT为每个连接提供一个映射，使得转换后的公网地址和端口对不可预测。此时TURN可以与STUN绑定提供穿越NAT的服务，即在公网服务器上提供一个“地址端口对”，所有此“地址端口对”接收到的数据会经由探测建立的连接转发到内网主机上。TURN分配的这个映射“地址端口对”会通过STUN响应发给内部主机，后者将此信息放入建立连接的信令中通知通信的对端。这种探针技术是一种通用方法，不用在NAT设备上为每种应用协议开发功能，相对于ALG方式有一定普遍性。但是TURN中继服务会成为通信瓶颈。而且在客户端中增加探针功能要求每个应用都要增加代码才能支持。


### 中间件技术


客户端会参与网关公网映射信息的维护，此时NAT网关只要理解客户端的请求并按照要求去分配转换表，不需要自己去分析客户端的应用层数据。其中UPnP就是这样一种方法。UPnP中文全称为通用即插即用，是一个通用的网络终端与网关的通信协议，具备信息发布和管理控制的能力。其中，网关映射请求可以为客户动态添加映射表项。


此时，NAT不再需要理解应用层携带的信息，只转换IP地址和端口信息。而客户端通过控制消息或信令发到公网侧的信息中，直接携带公网映射的IP地址和端口，接收端可以按照此信息建立数据连接。NAT网关在收到数据或连接请求时，按照UPnP建立的表项只转换地址和端口信息，不关心内容，再将数据转发到内网。这种方案需要网关、内部主机和应用程序都支持UPnP技术，且组网允许内部主机和NAT网关之间可以直接交换UPnP信令才能实施。


### 中继代理技术


准确说它不是NAT穿越技术，而是NAT旁路技术。简单说，就是在NAT网关所在的位置旁边放置一个应用服务器，这个服务器在内部网络和外部公网分别有自己的网络连接。客户端特定的应用产生网络请求时，将定向发送到应用代理服务器。应用代理服务器根据代理协议解析客户端的请求，再从服务器的公网侧发起一个新的请求，把客户端请求的内容中继到外部网络上，返回的相应反方向中继。这项技术和ALG有很大的相似性，它要求为每个应用类型部署中继代理业务，中间服务器要理解这些请求。


## STUN协议


> 💨链接:[官方文档](https://tools.ietf.org/html/rfc3489)



STUN（Simple Traversal of User Datagram Protocol Through Network Address Translators），即简单的用UDP穿透NAT，是个轻量级的协议，是基于UDP的完整的穿透NAT的解决方案。它允许应用程序发现它们与公共互联网之间存在的NAT和防火墙及其他类型。它也可以让应用程序确定NAT分配给它们的公网IP地址和端口号。STUN是一种Client/Server的协议，也是一种Request/Response的协议，默认端口号是3478。


### 消息头


所有的STUN消息都包含20个字节的消息头，包括16位的消息类型，16位的消息长度和128位的事务ID。


『16 bit : Message Type』+『16 bit : Message Length』+『128 bit :Transaction ID』


#### `Message Type`


- 0x0001：捆绑请求
- 0x0101：捆绑响应
- 0x0111：捆绑错误响应
- 0x0002：共享私密请求
- 0x0102：共享私密响应
- 0x0112：共享私密错误响应



#### `Message Length`


消息大小的字节数，但**💢不包括**20字节的头部


#### `Transaction ID`


128位的标识符，用于随机请求和响应，请求与其相应的所有响应具有**相同**的标识符。


### 消息属性


消息头之后是0或多个属性，每个属性进行TLV编码，包括16位的属性类型、16位的属性长度和变长属性值。


『16bit : Type』+『16 bit : Type Length』+『? bit: Type Value』


#### `Type`


- MAPPED-ADDRESS：MAPPED-ADDRESS属性表示映射过的IP地址和端口。它包括8位的地址族，16位的端口号及长度固定的IP地址。
- RESPONSE-ADDRESS：RESPONSE-ADDRESS属性表示响应的目的地址
- CHASNGE-REQUEST：客户使用32位的CHANGE-REQUEST属性来请求服务器使用不同的地址或端口号来发送响应。
- SOURCE-ADDRESS：SOURCE-ADDRESS属性出现在捆绑响应中，它表示服务器发送响应的源IP地址和端口。
- CHANGED-ADDRESS：如果捆绑请求的CHANGE-REQUEST属性中的“改变IP”和“改变端口”标志设置了，则CHANGED-ADDRESS属性表示响应发出的IP地址和端口号。
- USERNAME：USERNAME属性用于消息的完整性检查，用于消息完整性检查中标识共享私密。USERNAME通常出现在共享私密响应中，与PASSWORD一起。当使用消息完整性检查时，可有选择地出现在捆绑请求中。
- PASSWORD：PASSWORD属性用在共享私密响应中，与USERNAME一起。PASSWORD的值是变长的，用作共享私密，它的长度必须是4字节的倍数，以保证属性与边界对齐。
- MESSAGE-INTEGRITY：MESSAGE-INTEGRITY属性包含STUN消息的HMAC-SHA1，它可以出现在捆绑请求或捆绑响应中；MESSAGE-INTEGRITY属性必须是任何STUN消息的最后一个属性。它的内容决定了HMAC输入的Key值。
- ERROR-CODE：ERROR-CODE属性出现在捆绑错误响应或共享私密错误响应中。它的响应号数值范围从100到699。
- UNKNOWN-ATTRIBUTES：UNKNOWN-ATTRIBUTES属性只存在于其ERROR-CODE属性中的响应号为420的捆绑错误响应或共享私密错误响应中。
- REFLECTED-FROM：REFLECTED-FROM属性只存在于其对应的捆绑请求包含RESPONSE-ADDRESS属性的捆绑响应中。属性包含请求发出的源IP地址，它的目的是提供跟踪能力，这样STUN就不能被用作DOS攻击的反射器。



> 属性空间分为可选部分与强制部分，值超过`0x7fff`的属性是可选的，即客户或服务器即使不认识该属性也能够处理该消息；值小于或等于`0x7fff`的属性是强制理解的，即除非理解该属性，否则客户或服务器就不能处理该消息。



#### 具体的`ERROR-CODE`


- 400（错误请求）：请求变形了。客户在修改先前的尝试前不应该重试该请求。
- 401（未授权）：捆绑请求没有包含MESSAGE-INTERITY属性。
- 420（未知属性）：服务器不认识请求中的强制属性。
- 430（过期资格）：捆绑请求没有包含MESSAGE-INTEGRITY属性，但它使用过期
- 的共享私密。客户应该获得新的共享私密并再次重试。
- 431（完整性检查失败）：捆绑请求包含MESSAGE-INTEGRITY属性，但HMAC验
- 证失败。这可能是潜在攻击的表现，或者客户端实现错误
- 432（丢失用户名）：捆绑请求包含MESSAGE-INTEGRITY属性，但没有
- USERNAME属性。完整性检查中两项都必须存在。
- 433（使用TLS）：共享私密请求已经通过TLS（Transport Layer Security，即安全
- 传输层协议）发送，但没有在TLS上收到。
- 500（服务器错误）：服务器遇到临时错误，客户应该再次尝试。
- 600（全局失败）：服务器拒绝完成请求，客户不应该重试。



### 实现过程


1. 『客户端』➡『服务端』: 建立连接
1. 『客户端』➡『服务端』: 发送共享私密请求
1. 『客户端』⬅『服务端』: 返回共享私密错误响应
1. 『客户端』➡『服务端』: 发送共享私密请求
1. 『客户端』⬅『服务端』: 返回共享私密响应
1. 『客户端』➡『服务端』: 发送捆绑请求
1. 『客户端』⬅『服务端』: 返回捆绑请求错误响应
1. 『客户端』➡『服务端』: 发送捆绑请求
1. 『客户端』⬅『服务端』: 返回捆绑响应



#### 解释


客户通过带外方式获得STUN服务器信息后，就打开对应的地址和端口的连接，并开始与STUN服务器进行TLS协商。一旦打开了连接，客户就通过TCP协议发送共享私密请求，服务器生成共享私密响应。


STUN在客户和服务器间使用共享私密，用作捆绑请求和捆绑响应中的密匙。


客户使用UDP协议向STUN服务器发送捆绑请求，当捆绑请求消息到达服务器的时候，但是,💢它可能经过了**一个或者多个NAT**。💨结果是STUN服务器收到的捆绑请求消息的源IP地址被映射成**最靠近**STUN服务器的NAT的IP地址，STUN服务器把这个源IP地址和端口号复制到一个捆绑响应消息中，发送回拥有这个IP地址和端口号的客户端。


当**STUN客户端**收到捆绑响应消息之后，它会将自己发送捆绑请求时绑定的本地IP地址和端口号同捆绑响应消息中的IP地址和端口号进行比较，如果不匹配，就表示客户端正处于一个或者多个NAT的前面。


在`Full-Cone NAT`的情况下，在捆绑响应消息中的IP地址和端口是属于公网的，公网上的任何主机都可以使用这个IP地址和端口号向这个应用程序发送数据包，应用程序只需要在刚才发送捆绑请求的IP地址和端口上监听即可。


但是💢


客户可能并不在一个Full-Cone NAT的前面，实际上，它并不知道自己在一个什么类型的NAT的前面。为了确定NAT的类型，客户端使用附加的捆绑请求。


客户端再发送一个捆绑请求，这次发往另一个IP地址，但是使用的是跟上一次同一个源IP地址和源端口号，如果返回的数据包里面的IP地址和端口号和第一次返回的数据包中的不同，客户端就会知道它是在一个对称NAT的前面。


客户端为了确认自己是否在一个完全锥形NAT的前面，客户端可以发送一个带有标志的捆绑请求，这个标志告诉服务器使用**另一个IP地址**和端口发送捆绑响应。换句话说，如果客户端使X/Y的IP地址端口对向A/B的IP地址端口对发送捆绑请求，服务器就会使用源IP地址和源端口号为C/D的地址端口对向X/Y发送捆绑响应。如果客户端收到了这个响应，它就知道它是在一个Full-Cone NAT前面。


> 🛑 STUN协议允许客户端请求服务器从收到捆绑请求的IP地址往回发捆绑响应，但是要使用不同的端口号。这可以用来检查客户端是否在Port Restricted Cone NAT的前面还是在Restricted Cone NAT的前面。



## TURN协议


> 链接; [官方文档](https://tools.ietf.org/html/rfc5766)



TURN，在[RFC5766](https://tools.ietf.org/html/rfc5766)中定义，英文全称Traversal Using Relays around NAT（TURN）：Relay Extensions to Session Traversal Utilities for NAT（STUN），即使用中继穿透NAT：STUN的中继扩展，TURN与STUN的共同点都是通过修改应用层中的私网地址达到NAT穿透的效果，异同点是TURN是通过两方通讯的**『中间人』**方式实现穿透。


如果一个主机位于NAT的后面，在某些情况下它不能够与其他主机点对点直接连接。在这些情况下，它需要使用中间网点提供的中继连接服务。TURN协议就是用来允许主机控制**中继的操作并且使用中继与对端交换数据**。TURN与其他中继控制协议不同的是它能够**允许一个客户端使用一个中继地址与多个对端连接**。


### 术语


- TURN client：遵循RFC5766的STUN客户端。
- TURN server：遵循RFC5766的STUN服务器。
- Peer：TURN客户端希望连接的主机。TURN服务器为TURN客户端和它的对端中继流量，但Peer并不与TURN服务器使用TURN协议进行交互，它接收从TURN服务器发送过来的数据，并向TURN服务器发送数据。
- Transport Address：IP地址与端口号的组合。
- Host Transport Address：客户端或对端的传输地址。
- Server-Reflexive Transport Address：NAT公网侧的传输地址，该地址由NAT分配，相当于一个特定的主机传输地址。
- Relayed Transport Address：TURN服务器上的传输地址，用于客户端和对端中继数据。
- TURN Server Transport Address：TURN服务器上的传输地址，用于客户端发送STUN消息给服务器。
- Peer Transport Address：服务器看到的对端的传输地址，当对端是在NAT后面，则是对端的服务器反射传输地址。
- Allocation：通过Allocate请求将中继传输地址提供给客户端，除了中继状态外，还有许可和超时定时器等。
- 5-tuple：五元组，包括客户端IP地址和端口，服务器IP地址和端口和传输协议（包括UDP、TCP、TLS）的组合。
- Channel：通道号与对端传输地址的关联，一旦一个通道号与一个对端的传输地址绑定，客户端和服务器就能够利用带宽效应更大的通道数据消息来交换数据。
- Permission：一个对端允许使用它的IP地址和传输协议来发送数据到TURN服务器，服务器只为从对端发来的并且匹配一个已经存在的许可的流量中继到相应的客户端。
- Realm：服务器内用于描述服务器或内容的一个字符串，这个realm告诉客户端哪些用户名和密码的组合可用于认证请求。
- Nonce：服务器随机选择的一个字符串，包含在报文摘要中。为了防止中继攻击，服务器应该有规律的改变这个nonce。



## ICE


ICE的全称Interactive Connectivity Establishment（互动式连接建立），由IETF的MMUSIC工作组开发出来的，它所提供的是一种框架，使各种NAT穿透技术可以实现统一。ICE跟STUN和TURN不一样，ICE不是一种协议，而是一个框架（Framework），它整合了STUN和TURN。


#### 举例


- A收集所有的IP地址，并找出其中可以从STUN服务器和TURN服务器收到流量的地址；
- A向STUN服务器发送一份地址列表，然后按照排序的地址列表向B发送启动信息，目的是实现节点间的通信；
- B向启动信息中的每一个地址发送一条STUN请求；
- A将第一条接收到的STUN请求的回复信息发送给B；
- B接到STUN回复后，从中找出那些可在A和B之间实现通信的地址；
- 利用列表中的排序列最高的地址进一步的设备间通信。



> 由于该技术是建立在多种NAT穿透协议的基础之上，并且提供了一个统一的框架，所以ICE具备了所有这些技术的优点，同时还避免了任何单个协议可能存在的缺陷。因此，ICE可以实现在未知网络拓扑结构中实现的设备互连，而且不需要进行对手配置。另外，由于该技术不需要为VoIP流量手动打开防火墙，所以也不会产生潜在的安全隐患。



## 打洞注意的问题


### 空闲状态下的超时问题


由于UDP转换协议提供的“洞”不是绝对可靠的，多数NAT设备内部都有一个UDP转换的空闲状态计时器，如果在一段时间内没有 UDP数据通信，NAT设备会关掉由“打洞”操作打出来的“洞”作为应用程序来讲如果想要做到与设备无关，就最好在穿越NAT后 设定一个穿越的有效期。这个有效期与NAT设备内部的配置有关，目前没有标准有效期，最短的只有20秒左右。在这个有效期内， 即使没有P2P数据报文需要传输，应用程序为了维持该“洞”可以 正常工作，也必须向对方发送“打洞”维持报文。这个维持报文 是需要双方应用都发送的，只有一方发送不会维持另一方的映射 关系正常工作。除了频繁发送“打洞”维持报文以外，还有一个 方法就是在当前的“洞”有效期过期之前，P2P客户端双方重新 “打洞”，丢弃原有的“洞”，这也不失为一个有效的方法。


### TCP打洞


建立穿越NAT设备的P2P的TCP连接只比UDP复杂一点点，TCP协议的 “打洞”从协议层来看是与UDP的“打洞”过程非常相似的。尽管如此，基于TCP协议的打洞至今为止还没有被很好的理解，这也造成了的对其提供支持的NAT设备不是很多。在NAT设备支持的前提下，基于TCP的“打洞”技术实际上与基于UDP的“打洞”技术一样快捷、可靠。实际上，只要NAT设备支持的话，基于TCP的P2P技术的健壮性将比基于UDP技术的更强一些，因为TCP协议的状态机给出了一种标准的方法来精确的获取某个TCP session的生命期，而UDP协议则无法做到这一点。


### 什么是Hairpin技术？


Hairpin技术又被称为Hairpin NAT、Loopback NAT或Hairpin Translation。Hairpin技术需要NAT网关支持，它能够让两台位于同一台NAT网关后面的主机，通过对方的公网地址和端口相互访问，NAT网关会根据一系列规则，将对内部主机发往其NAT公网IP地址的报文进行转换，并从私网接口发送给目标主机。目前有很多NAT设备不支持该技术，这种情况下，NAT网关在一些特定场合下将会阻断P2P穿越NAT的行为，打洞的尝试是无法成功的。好在现在已经有越来越多的NAT设备商开始加入到对该转换的支持中来。